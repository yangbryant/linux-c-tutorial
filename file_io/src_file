/**
  @file   basic.c - Sample application to control a device using BASIC command class interface.

  @author David Chow

  @version    1.0 26-1-15  Initial release

  @copyright ? 2014 SIGMA DESIGNS, INC. THIS IS AN UNPUBLISHED WORK PROTECTED BY SIGMA DESIGNS, INC.
  AS A TRADE SECRET, AND IS NOT TO BE USED OR DISCLOSED EXCEPT AS PROVIDED Z-WAVE CONTROLLER DEVELOPMENT KIT
  LIMITED LICENSE AGREEMENT. ALL RIGHTS RESERVED.

NOTICE: ALL INFORMATION CONTAINED HEREIN IS CONFIDENTIAL AND/OR PROPRIETARY TO SIGMA DESIGNS
AND MAY BE COVERED BY U.S. AND FOREIGN PATENTS, PATENTS IN PROCESS, AND ARE PROTECTED BY TRADE SECRET
OR COPYRIGHT LAW. DISSEMINATION OR REPRODUCTION OF THE SOURCE CODE CONTAINED HEREIN IS EXPRESSLY FORBIDDEN
TO ANYONE EXCEPT LICENSEES OF SIGMA DESIGNS  WHO HAVE EXECUTED A SIGMA DESIGNS' Z-WAVE CONTROLLER DEVELOPMENT KIT
LIMITED LICENSE AGREEMENT. THE COPYRIGHT NOTICE ABOVE IS NOT EVIDENCE OF ANY ACTUAL OR INTENDED PUBLICATION OF
THE SOURCE CODE. THE RECEIPT OR POSSESSION OF  THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR
IMPLY ANY RIGHTS  TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL A PRODUCT
THAT IT  MAY DESCRIBE.


THE SIGMA PROGRAM AND ANY RELATED DOCUMENTATION OR TOOLS IS PROVIDED TO COMPANY "AS IS" AND "WITH ALL FAULTS",
WITHOUT WARRANTY OF ANY KIND FROM SIGMA. COMPANY ASSUMES ALL RISKS THAT LICENSED MATERIALS ARE SUITABLE OR ACCURATE
FOR COMPANY'S NEEDS AND COMPANY'S USE OF THE SIGMA PROGRAM IS AT COMPANY'S OWN DISCRETION AND RISK. SIGMA DOES NOT
GUARANTEE THAT THE USE OF THE SIGMA PROGRAM IN A THIRD PARTY SERVICE ENVIRONMENT OR CLOUD SERVICES ENVIRONMENT WILL BE:
(A) PERFORMED ERROR-FREE OR UNINTERRUPTED; (B) THAT SIGMA WILL CORRECT ANY THIRD PARTY SERVICE ENVIRONMENT OR
CLOUD SERVICE ENVIRONMENT ERRORS; (C) THE THIRD PARTY SERVICE ENVIRONMENT OR CLOUD SERVICE ENVIRONMENT WILL
OPERATE IN COMBINATION WITH COMPANY'S CONTENT OR COMPANY APPLICATIONS THAT UTILIZE THE SIGMA PROGRAM;
(D) OR WITH ANY OTHER HARDWARE, SOFTWARE, SYSTEMS, SERVICES OR DATA NOT PROVIDED BY SIGMA. COMPANY ACKNOWLEDGES
THAT SIGMA DOES NOT CONTROL THE TRANSFER OF DATA OVER COMMUNICATIONS FACILITIES, INCLUDING THE INTERNET, AND THAT
THE SERVICES MAY BE SUBJECT TO LIMITATIONS, DELAYS, AND OTHER PROBLEMS INHERENT IN THE USE OF SUCH COMMUNICATIONS
FACILITIES. SIGMA IS NOT RESPONSIBLE FOR ANY DELAYS, DELIVERY FAILURES, OR OTHER DAMAGE RESULTING FROM SUCH ISSUES.
SIGMA IS NOT RESPONSIBLE FOR ANY ISSUES RELATED TO THE PERFORMANCE, OPERATION OR SECURITY OF THE THIRD PARTY SERVICE
ENVIRONMENT OR CLOUD SERVICES ENVIRONMENT THAT ARISE FROM COMPANY CONTENT, COMPANY APPLICATIONS OR THIRD PARTY CONTENT.
SIGMA DOES NOT MAKE ANY REPRESENTATION OR WARRANTY REGARDING THE RELIABILITY, ACCURACY, COMPLETENESS, CORRECTNESS, OR
USEFULNESS OF THIRD PARTY CONTENT OR SERVICE OR THE SIGMA PROGRAM, AND DISCLAIMS ALL LIABILITIES ARISING FROM OR RELATED
TO THE SIGMA PROGRAM OR THIRD PARTY CONTENT OR SERVICES. TO THE EXTENT NOT PROHIBITED BY LAW, THESE WARRANTIES ARE EXCLUSIVE.
SIGMA OFFERS NO WARRANTY OF NON-INFRINGEMENT, TITLE, OR QUIET ENJOYMENT. NEITHER SIGMA NOR ITS SUPPLIERS OR LICENSORS
SHALL BE LIABLE FOR ANY INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OR LOSS (INCLUDING DAMAGES FOR LOSS OF
BUSINESS, LOSS OF PROFITS, OR THE LIKE), ARISING OUT OF THIS AGREEMENT WHETHER BASED ON BREACH OF CONTRACT,
INTELLECTUAL PROPERTY INFRINGEMENT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY, PRODUCT LIABILITY OR OTHERWISE,
EVEN IF SIGMA OR ITS REPRESENTATIVES HAVE BEEN ADVISED OF OR OTHERWISE SHOULD KNOW ABOUT THE POSSIBILITY OF SUCH DAMAGES.
THERE ARE NO OTHER EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS INCLUDING FOR SOFTWARE, HARDWARE, SYSTEMS, NETWORKS OR
ENVIRONMENTS OR FOR MERCHANTABILITY, NONINFRINGEMENT, SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.

The Sigma Program  is not fault-tolerant and is not designed, manufactured or intended for use or resale as on-line control
equipment in hazardous environments requiring fail-safe performance, such as in the operation of nuclear facilities,
aircraft navigation or communication systems, air traffic control, direct life support machines, or weapons systems,
in which the failure of the Sigma Program, or Company Applications created using the Sigma Program, could lead directly
to death, personal injury, or severe physical or environmental damage ("High Risk Activities").  Sigma and its suppliers
specifically disclaim any express or implied warranty of fitness for High Risk Activities.Without limiting Sigma's obligation
of confidentiality as further described in the Z-Wave Controller Development Kit Limited License Agreement, Sigma has no
obligation to establish and maintain a data privacy and information security program with regard to Company's use of any
Third Party Service Environment or Cloud Service Environment. For the avoidance of doubt, Sigma shall not be responsible
for physical, technical, security, administrative, and/or organizational safeguards that are designed to ensure the
security and confidentiality of the Company Content or Company Application in any Third Party Service Environment or
Cloud Service Environment that Company chooses to utilize.
*/

#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include "../../include/zip_api.h"

#include "util.h"
#include "global.h"
#include "scene.h"
#include "linkage.h"

#define  SEC2_ENTER_KEY_REQ  1   ///< Bit-mask for allowing S2 key request callback
#define  SEC2_ENTER_DSK      2   ///< Bit-mask for allowing S2 DSK callback
#define  ADD_NODE_STS_UNKNOWN    0   ///<Add node status: unknown
#define  ADD_NODE_STS_PROGRESS   1   ///<Add node status: in progress
#define RESET_NW_STS_UNKNOWN 0
#define RESET_NW_STS_PROGRESS 1
#define RESET_NW_STS_DONE  2
#define ADD_NODE_STS_DONE       2   ///<Add node status: done
#define RM_NODE_STS_UNKNOWN    0   ///<Remove node status: unknown
#define RM_NODE_STS_PROGRESS   1   ///<Remove node status: in progress
#define RM_NODE_STS_DONE       2   ///<Remove node status: done

#define ADD_RM_DEVICE_TIMEOUT	(120 * 1000)

/** user application context*/
typedef struct
{
	volatile int init_status;   ///< Network initialization status. 0=unknown; 1=done
	volatile int node_status;     ///< Remove node status.  0=unknown; 1=in progress; 2=done
	volatile unsigned sec2_cb_enter;
	volatile int sec2_cb_exit;
	uint8_t sec2_add_node;
	sec2_add_prm_t sec2_add_prm;

	int     use_ipv4;           ///< Flag to indicate whether to use IPv4 or IPv6. 1=IPv4; 0=IPv6
	zwnet_p zwnet;              ///< Network handle

	struct Global_Client *gClient; 
	guint addnodetimer;
} hl_appl_ctx_t;

static hl_appl_ctx_t g_appl_ctx = {0};

/**
  prompt_str - prompt for a string from user
  @param[in] disp_str   The prompt string to display
  @param[in] out_buf_sz The size of out_str buffer
  @param[out] out_str   The buffer where the user input string to be stored
  @return          The out_str if successful; else NULL.
  */
static char  *prompt_str(hl_appl_ctx_t *hl_appl, const char *disp_str, int out_buf_sz, char *out_str)
{
	int retry;
	puts(disp_str);
	retry = 3;
	while (retry-- > 0)
	{
		if (fgets(out_str, out_buf_sz, stdin) && (*out_str) && ((*out_str) != '\n'))
		{
			char *newline;
			//Remove newline character

			newline = strchr(out_str, '\n');
			if (newline)
			{
				*newline = '\0';
			}
			return out_str;
		}
	}
	return NULL;
}


/**
  prompt_hex - prompt for an hexadecimal unsigned integer input from user
  @param[in] str   The prompt string to display
  @return          The unsigned integer that user has input
  */
static unsigned prompt_hex(hl_appl_ctx_t *hl_appl, char *str)
{
	char user_input_str[36];
	unsigned  ret;

	if (prompt_str(hl_appl, str, 36, user_input_str))
	{
#ifdef USE_SAFE_VERSION
		if (sscanf_s(user_input_str, "%x", &ret) == 1)
		{
			return ret;
		}
#else
		if (sscanf(user_input_str, "%x", &ret) == 1)
		{
			return ret;
		}
#endif
	}
	return 0;
}


/**
  prompt_char - prompt for a character input from user
  @param[in] str   The prompt string to display
  @return          The character that user has input. Null character on error.
  */
static char prompt_char(hl_appl_ctx_t *hl_appl, char *str)
{
	char ret[80];

	if (prompt_str(hl_appl, str, 80, ret))
	{
		return ret[0];
	}
	return 0;
}


/**
  prompt_yes - prompt for yes or no from user
  @param[in] str   The prompt string to display
  @return          1 = user has input yes, 0 =  user has input no
  */
static int prompt_yes(hl_appl_ctx_t *hl_appl, char *str)
{
	char c;

	c = prompt_char(hl_appl, str);
	if (c == 'y' || c == 'Y')
	{
		return 1;
	}
	return 0;
}

/**
  hl_nw_tx_cb - Callback function to notify application transmit data status
  @param[in]	user	    The high-level api context
  param[in]	tx_sts	    Transmit status ZWNET_TX_xx
  @return
  */
static void hl_nw_tx_cb(void *user, uint8_t tx_sts)
{
	static const char    *tx_cmplt_sts[] = {"ok",
		"timeout: no ACK received",
		"system error",
		"destination host needs long response time",
		"frame failed to reach destination host"
	};

	if (tx_sts == TRANSMIT_COMPLETE_OK)
	{
		printf("Send command completed\n");
	}
	else
	{
		printf("Send command completed with error:%s\n",
				(tx_sts < sizeof(tx_cmplt_sts)/sizeof(char *))? tx_cmplt_sts[tx_sts]  : "unknown");
	}
}


/**
  hl_nw_node_cb - Callback function to notify node is added, deleted, or updated
  @param[in]	user	    The high-level api context
  @param[in]	noded	Node
  @param[in]	mode	    The node status
  @return
  */
static void hl_nw_node_cb(void *user, zwnoded_p noded, int mode)
{
	hl_appl_ctx_t *hl_appl = (hl_appl_ctx_t *)user;
	zwifd_t			ifd;
	switch (mode)
	{
		case ZWNET_NODE_STATUS_ALIVE:
			{
				printf("node:%u is alive\n", (unsigned)noded->nodeid);
			}
			break;

		case ZWNET_NODE_STATUS_DOWN:
			{
				printf("node:%u is down or sleeping\n", (unsigned)noded->nodeid);
			}
			break;

		case ZWNET_NODE_ADDED:
			printf("Node %d added\n", (unsigned)noded->nodeid);
			break;

		case ZWNET_NODE_REMOVED:
			printf("Node %d removed\n", (unsigned)noded->nodeid);
			break;

		default:
			printf("node:%u get mode=%d\n", (unsigned)noded->nodeid, mode);
	}
	return;
}

static void package_zwave_report_to_json_object(zwifd_p ifd, uint8_t unit, uint8_t ktype,  int32_t value)
{
	json_object *jObj;
	json_object *jAddr;
	json_object *jValue;
	json_object *jCmd;
	json_object *jtype;
	json_object *jdevinfo;

	const char* cmds = "{ \
					   \"protocal\":1,\
					   \"type\":4, \
					}";

	jdevinfo = json_object_new_object();
	jObj = json_tokener_parse(cmds);
	jAddr = json_object_new_int((ifd->nodeid << 8) | (ifd->epid));
	jCmd = json_object_new_int(ifd->cls);
	jtype = json_object_new_int((unit) | (ktype << 8));
	jValue = json_object_new_int(value);
	json_object_object_add(jdevinfo, "addr", jAddr);
	json_object_object_add(jdevinfo, "cmd", jCmd);
	json_object_object_add(jdevinfo, "vtype", jtype);
	json_object_object_add(jdevinfo, "value", jValue);
	json_object_object_add(jObj, DEVICE_INFOR , jdevinfo);
	report_json_object_to_all_client(jObj);

	json_object_put(jObj);

	return 0;
}

static void basic_report_callback(zwifd_p ifd, uint8_t level, time_t ts)
{
	printf("nodeid[%d] level=%d\n", ifd->nodeid, level);
	package_zwave_report_to_json_object(ifd, 0, 0, level);
}

static void switch_report_callback(zwifd_p ifd, uint8_t on, time_t ts)
{
	printf("Switch binary nodeid[%d] value = %d/n",ifd->nodeid,on);
	package_zwave_report_to_json_object(ifd, 0, 0, on);

	return ;
}

static void sensor_notification_alarm_report_callback(zwifd_p ifd, zwalrm_p  alarm_info, time_t ts)
{

	printf("Sensor alarm Report:node[%d] type=%d, precision =%d, data = %d\n",
			ifd->nodeid, alarm_info->ex_type,0, alarm_info->ex_event);
	package_zwave_report_to_json_object(ifd, 0, alarm_info->ex_type,alarm_info->ex_event);

	return ;
}

static void battery_report_callback(zwifd_p ifd, uint8_t level, time_t ts)
{
	printf("Battery Report:node[%d] type=%d, precision =%d, data = %d\n",
			ifd->nodeid, 0, 0, level);
	package_zwave_report_to_json_object(ifd, 0, 0, level);

	return ;
}

static void zwrep_meter_report_callback(zwifd_p ifd, zwmeter_dat_p data, time_t ts)
{

	int dvalue ;	
	
	switch(data->size) {
		case 1:
			dvalue = data->data[0];
			break;
		case 2:
			dvalue = (data->data[0] << 8) | data->data[1];
			break;
		case 4:
			dvalue = (data->data[0] << 24) | (data->data[1] << 16) | (data->data[2] << 8) | data->data[3];
			break;
	}

	printf("Meter Report:node[%d] tyep=%d, value=%d\n",
			ifd->nodeid, data->type,0);
	package_zwave_report_to_json_object(ifd, 0,data->type, dvalue);

	return ;
}

static void zwrep_bsensor_callback_func(zwifd_p ifd, uint8_t state, uint8_t type, time_t ts)
{
	printf("Binery Sensor Report:node[%d] tyep=%d, state=%d\n",
			ifd->nodeid, type, state);
	package_zwave_report_to_json_object(ifd, 0, type, state);
	triggered_by_device_callback(g_appl_ctx.gClient, ((ifd->nodeid << 8) | (ifd->epid)), (type << 8), state); 
	return;
}
static void sensor_multilevel_report_callback(zwifd_p ifd, zwsensor_p data, time_t ts)
{
	int dvalue;
	
	switch(data->size) {
		case 1:
			dvalue = data->data[0];
			break;
		case 2:
			dvalue = (data->data[0] << 8) | data->data[1];
			break;
		case 4:
			dvalue = (data->data[0] << 24) | (data->data[1] << 16) | (data->data[2] << 8) | data->data[3];
			break;
	}

	printf("sensor multilevel Report:node[%d] type=%d, unit=%d, data = %d\n",
			ifd->nodeid, data->type, data->unit, dvalue);
	package_zwave_report_to_json_object(ifd, data->unit, data->type, dvalue);

	triggered_by_device_callback(g_appl_ctx.gClient, ((ifd->nodeid << 8) | (ifd->epid)), data->type, dvalue); 
}
static void doorlock_report_callback(zwifd_p ifd, zwdlck_op_p op_sts, time_t ts)
{
	package_zwave_report_to_json_object(ifd, 0, 0, op_sts->cond);
	return;
}
static void switch_multilevel_report_callback(zwifd_p ifd, uint8_t level, time_t ts)
{
	printf("nodeid[%d] level=%d\n", ifd->nodeid, level);
	package_zwave_report_to_json_object(ifd, 0, 0, level);
	return ;
}
static json_object *create_json_object_for_nodelist(hl_appl_ctx_t *hl_appl)
{
	struct json_object *jZnode;
	zwnoded_t node;
	int result;

	jZnode = json_object_new_array();

	result = zwnet_get_node(hl_appl->zwnet, &node);
	if (result != 0) {
		return jZnode;
	}

	while(!zwnode_get_next(&node, &node)) {
		json_object_array_add(jZnode, json_object_new_int(node.nodeid));
	}
	return jZnode;
}
static json_object *create_json_object_for_zwavenode(hl_appl_ctx_t *hl_appl, zwnoded_p pnode)
{
	zwepd_t ep;
	zwifd_t intf;
	if_sensor_data_t    *sup_snsr = NULL;
	uint8_t snsr_cnt;
	int i;
	struct json_object *jZnode;
	struct json_object *jtemp;
	struct json_object *jEndpointArray;
	struct json_object *jEndpoint;
	struct json_object *jClassArray;
	struct json_object *jClass;

	struct json_object *jAttrArray;

	/*
	 * for zwave node info\
	 */
	jZnode = json_object_new_object();
	jtemp = json_object_new_int(pnode->nodeid);
	json_object_object_add(jZnode, "nodeid", jtemp);
	jtemp = json_object_new_int(pnode->vid);		//add vid
	json_object_object_add(jZnode, "vid", jtemp);
	jtemp = json_object_new_int(pnode->type);
	json_object_object_add(jZnode, "type", jtemp);
	jtemp = json_object_new_int(pnode->pid);
	json_object_object_add(jZnode, "pid", jtemp);
	jtemp = json_object_new_int((pnode->proto_ver << 16) | (pnode->app_ver));
	json_object_object_add(jZnode, "ver", jtemp);
	jtemp = json_object_new_int((pnode->sensor << 16) | (pnode->sleep_cap << 8) | pnode->listen);
	json_object_object_add(jZnode, "sensorflag", jtemp);
	
	jEndpointArray = json_object_new_array();
	if (!zwnode_get_ep(pnode, &ep)) {//get first endpoint of the node

		do {
			//for one endpoint info
			jEndpoint = json_object_new_object();	
			jtemp = json_object_new_int(ep.epid);
			json_object_object_add(jEndpoint, "epid", jtemp);
			jtemp = json_object_new_int(ep.generic);
			json_object_object_add(jEndpoint, "generic", jtemp);
			jtemp = json_object_new_int(ep.specific);
			json_object_object_add(jEndpoint, "specific", jtemp);
			jtemp = json_object_new_string(&ep.name);
			json_object_object_add(jEndpoint, "name", jtemp);

			jClassArray = json_object_new_array();
			if (!zwep_get_if(&ep, &intf)) { //get first interface of the endpoint
				do {
					//for one class
					jClass = json_object_new_object();
					jtemp = json_object_new_int(intf.cls);
					json_object_object_add(jClass, "cls", jtemp);
					jtemp = json_object_new_int((intf.ver << 8) | intf.real_ver);

					switch(intf.cls) {
						case COMMAND_CLASS_SENSOR_BINARY:
						case COMMAND_CLASS_SENSOR_MULTILEVEL:
							jAttrArray = json_object_new_array();
							sup_snsr = (if_sensor_data_t*)intf.data;
							snsr_cnt = intf.data_cnt;
							for (i = 0; i < snsr_cnt; i++) {
								jtemp = json_object_new_int(sup_snsr[i].sensor_type);
								json_object_array_add(jAttrArray, jtemp);
							}
							json_object_object_add(jClass, "attr", jAttrArray);
							break;
					}

					json_object_array_add(jClassArray, jClass);
				}while (!zwif_get_next(&intf, &intf)); //get next interface
			}
			json_object_object_add(jEndpoint, "cclass", jClassArray);
			json_object_array_add(jEndpointArray, jEndpoint);
		}while (!zwep_get_next(&ep, &ep)); //get next endpoint
		json_object_object_add(jZnode, "endpoint", jEndpointArray);
	}
	return jZnode;
}
static void hl_nw_new_node_parse_by_node(hl_appl_ctx_t *hl_appl, zwnoded_p pnode)
{
	zwepd_t ep;
	zwifd_t intf;
	if_sensor_data_t    *sup_snsr = NULL;
	uint8_t snsr_cnt;
	int i;

	if (!zwnode_get_ep(pnode, &ep)) {//get first endpoint of the node
		do {
			if (!zwep_get_if(&ep, &intf)) { //get first interface of the endpoint
				do {
					switch(intf.cls) {

						case COMMAND_CLASS_BASIC:
							printf("get command class basic device[%d]\n", intf.nodeid);
							zwif_basic_rpt_set(&intf, basic_report_callback); 
							//Free interface data
							if (intf.data_cnt > 0)
							{
								free(intf.data);
							}
							break;

						case COMMAND_CLASS_SWITCH_BINARY:

							printf("get command class switch binary device[%d]\n",intf.nodeid);
							zwif_switch_rpt_set(&intf, switch_report_callback);
							//Free interface data
							if (intf.data_cnt > 0)
							{
								free(intf.data);
							}
							break;

						case COMMAND_CLASS_SENSOR_BINARY:
							printf("get command class sensor binary device[%d], data_cnt=%d\n", intf.nodeid, intf.data_cnt);
							zwif_bsensor_rpt_set(&intf, zwrep_bsensor_callback_func); 
							sup_snsr = (if_sensor_data_t*)intf.data;
							snsr_cnt = intf.data_cnt;

							for (i = 0; i < snsr_cnt; i++) {
								printf("TYPE:%d\n", sup_snsr[i].sensor_type);
							}

							if (intf.data_cnt > 0) {
								free(intf.data);
							}
							break;

						case COMMAND_CLASS_SENSOR_ALARM :

							printf("get command class sensor alarm[%d]\n",intf.nodeid);
							zwif_alrm_rpt_set(&intf, sensor_notification_alarm_report_callback);
							//Free interface data
							if (intf.data_cnt > 0)
							{
								free(intf.data);
							}

							break;

						case COMMAND_CLASS_BATTERY :

							printf("get command class battery [%d]\n",intf.nodeid);
							zwif_battery_rpt_set(&intf, battery_report_callback);
							//Free interface data
							if (intf.data_cnt > 0)
							{
								free(intf.data);
							}

							break; 

						case COMMAND_CLASS_METER:

							printf("get command class meter callback[%d], data_cnt=%d\n", intf.nodeid, intf.data_cnt);
							zwif_meter_rpt_set(&intf, zwrep_meter_report_callback); 
							if (intf.data_cnt > 0) {
								free(intf.data);
							}

							break;

						case COMMAND_CLASS_DOOR_LOCK:
							printf("get command class doorlock device[%d]\n", intf.nodeid);
							zwif_dlck_op_rpt_set(&intf, doorlock_report_callback); 
							if (intf.data_cnt > 0) {
								free(intf.data);
							}
							break;

						case COMMAND_CLASS_SENSOR_MULTILEVEL:
							printf("get command class sensor multilevel device[%d], data_cnt=%d\n", intf.nodeid, intf.data_cnt);
							sup_snsr = (if_sensor_data_t*)intf.data;
							snsr_cnt = intf.data_cnt;

							zwif_sensor_rpt_set(&intf, sensor_multilevel_report_callback);
							for (i = 0; i < snsr_cnt; i++) {
								printf("TYPE:%d\n", sup_snsr[i].sensor_type);
							}
							printf("%s %d\n", __func__, __LINE__);
							if (intf.data_cnt > 0) {
								free(intf.data);
							}
							break;

						case COMMAND_CLASS_SWITCH_MULTILEVEL:
							printf("get command class switch multilevel device[%d]\n", intf.nodeid);

							zwif_level_rpt_set(&intf, switch_multilevel_report_callback);
							printf("%s %d\n", __func__, __LINE__);
							if (intf.data_cnt > 0) {
								free(intf.data);
							}
							break;

						default:
							break;
					}
				}while (!zwif_get_next(&intf, &intf)); //get next interface
			}
		}while (!zwep_get_next(&ep, &ep)); //get next endpoint
	}
}
static void hl_nw_alldevices_node_list(hl_appl_ctx_t *hl_appl)
{
	zwnoded_t node;
	json_object *jObj = NULL;
	json_object *jdevinfo = NULL;
	json_object *jNode = NULL;

	const char* cmds = "{ \
					   \"protocal\":1,\
					   \"type\":11, \
					}";
	jObj = json_tokener_parse(cmds);
	jdevinfo = json_object_new_object();
	jNode = create_json_object_for_nodelist(hl_appl);
	json_object_object_add(jdevinfo, "list", jNode);
	json_object_object_add(jObj, DEVICE_INFOR, jdevinfo);
	report_json_object_to_all_client(jObj);
	json_object_put(jObj);
	return ;
}
static void hl_nw_rm_node_parse_by_nodeid(hl_appl_ctx_t *hl_appl, int nodeid)
{
	zwnoded_t node;
	json_object *jObj = NULL;
	json_object *jtemp = NULL;
	json_object *jdevinfo = NULL;

	const char* cmds = "{ \
					   \"protocal\":1,\
					   \"type\":10, \
					}";

	jObj = json_tokener_parse(cmds);
	jdevinfo = json_object_new_object();
	jtemp = json_object_new_int(nodeid);
	json_object_object_add(jdevinfo, "nodeid", jtemp);
	json_object_object_add(jObj, DEVICE_INFOR, jdevinfo);
	report_json_object_to_all_client(jObj);
	json_object_put(jObj);
	return ;
}

static void hl_nw_add_node_promote(hl_appl_ctx_t *hl_appl, int nodeid)
{
	zwnoded_t node;
	json_object *jObj = NULL;
	json_object *jtemp = NULL;
	json_object *jdevinfo = NULL;

	const char* cmds = "{ \
					   \"protocal\":1,\
					   \"type\":12, \
					}";
	jObj = json_tokener_parse(cmds);
	jdevinfo = json_object_new_object();
	jtemp = json_object_new_int(nodeid);
	json_object_object_add(jdevinfo, "nodeid", jtemp);
	json_object_object_add(jObj, DEVICE_INFOR, jdevinfo);
	report_json_object_to_all_client(jObj);
	json_object_put(jObj);
	return ;
}
static void hl_nw_new_node_parse_by_nodeid(hl_appl_ctx_t *hl_appl, int nodeid)
{
	zwnoded_t node;
	json_object *jNode= NULL;
	json_object *jObj = NULL;

	const char* cmds = "{ \
					   \"protocal\":1,\
					   \"type\":9, \
					}";

	printf("hl_nw_new_node_parse %d\n", nodeid);
	if (ZW_ERR_NONE == zwnet_get_node_by_id(hl_appl->zwnet, nodeid, &node)) {
		hl_nw_new_node_parse_by_node(hl_appl, &node);

		jObj = json_tokener_parse(cmds);
		jNode = create_json_object_for_zwavenode(hl_appl, &node);	
		json_object_object_add(jObj, DEVICE_INFOR ,jNode);
		report_json_object_to_all_client(jObj);
		json_object_put(jObj);
	} else {
		printf("nodeid found but no nodestruct  please check\n");
	}
}

static int hl_nw_set_alldevice_callback(hl_appl_ctx_t *hl_appl)
{
	zwnoded_t node;
	int result;

	//get first controller node
	result = zwnet_get_node(hl_appl->zwnet, &node);
	if (result != 0) {
		return result;
	}

	while(!zwnode_get_next(&node, &node)) {
		hl_nw_new_node_parse_by_node(hl_appl, &node);
		/*
		jNode = create_json_object_for_zwavenode(hl_appl, &node);
		printf("Got one Node:\n");
		printf("%s\n", json_object_to_json_string(jNode));
		json_object_put(jNode);
		*/
	}
	return 0;
}
/**
  hl_nw_notify_cb - Callback function to notify the status of current operation
  @param[in]	user	The high-level api context
  param[in]	op		Network operation ZWNET_OP_XXX
  @param[in]	ret		The status of current operation
  @return
  */
static void hl_nw_notify_cb(void *user, uint8_t op, uint16_t sts, uint8_t node_id)
{
	hl_appl_ctx_t *hl_appl = (hl_appl_ctx_t *)user;
	zwifd_t			ifd;
	unsigned char local_ip[16];
	unsigned short listenPort = 4123;
	int ipv4;

	//Check whether the status is progress status of discovering each detailed node information
	if (sts & OP_GET_NI_TOTAL_NODE_MASK)
	{
		uint16_t    total_nodes;
		uint16_t    cmplt_nodes;

		total_nodes = (sts & OP_GET_NI_TOTAL_NODE_MASK) >> 8;
		cmplt_nodes = sts & OP_GET_NI_NODE_CMPLT_MASK;
		printf("Get node info %u/%u(%d) completed\n", cmplt_nodes, total_nodes, node_id);
		hl_nw_new_node_parse_by_nodeid(hl_appl, node_id);
		return;
	}

	switch (op)
	{
		case ZWNET_OP_INITIALIZE:
			printf("\nInitialization status:%u\n",(unsigned)sts);
			if (sts == OP_DONE)
			{
				zwnetd_p nw_desp;

				//Get network descriptor
				nw_desp = zwnet_get_desc(hl_appl->zwnet);
				printf("network id:%08X, Z/IP controller id:%u\n", nw_desp->id, nw_desp->ctl_id);
				if (zwnet_get_if_by_id(hl_appl->zwnet, 1, 0, COMMAND_CLASS_ZIP_GATEWAY, &ifd) == 0 ) {
					if (zwnet_ip_aton("fd00:aaaa::1234", local_ip, &ipv4) == 0) { 
						if ( zwif_gw_unsolicit_set(&ifd, &local_ip, listenPort)== 0 )	// set port to which client is listening to
						{
							printf("IP address and Port set\n");
						}
						else
						{
							printf("IP address and Port could NOT set\n");
						}
					}
				} else {
					printf("TAP0, get ipaddress failed\n");
				}
				hl_appl->init_status = 1;
				hl_nw_set_alldevice_callback(hl_appl);
			//	printf("\n(1) Set basic value (0 ~ 255):\n(x) Exit\n");
			//	printf("Select your choice:\n");
			}
			else
			{
				nw_deinit(hl_appl);
				nw_init(hl_appl->gClient);
				printf("Reinit network\n");
			}
			break;

		case ZWNET_OP_RM_NODE:
			printf("Remove node status:%u, nodeid=%d\n", (unsigned)sts, node_id);
			if (sts == OP_DONE) {
				hl_appl->node_status = RM_NODE_STS_DONE;
				hl_nw_rm_node_parse_by_nodeid(hl_appl, node_id);
			} else if (sts == OP_FAILED) {
				hl_appl->node_status = RM_NODE_STS_UNKNOWN;
			}
			if (hl_appl->addnodetimer) {
				g_source_remove(hl_appl->addnodetimer);
				hl_appl->addnodetimer = 0;
				printf("Rmove add/rm timeout timer\n");
			}
			break;

		case ZWNET_OP_ADD_NODE:
			printf("Add node status:%d, nodeid=%d\n", (unsigned)sts, node_id);
			if (sts == OP_DONE) {
				hl_appl->sec2_cb_enter = 0;
				hl_appl->sec2_cb_exit = 1;
				hl_appl->node_status = ADD_NODE_STS_DONE;

				//here parse all device  register all the interface
				hl_nw_new_node_parse_by_nodeid(hl_appl, node_id);
			} else if (sts == OP_FAILED) {
				hl_appl->sec2_cb_enter = 0;
				hl_appl->sec2_cb_exit = 1;
				hl_appl->node_status = ADD_NODE_STS_UNKNOWN;
			} else if (sts == OP_ADD_NODE_PROTOCOL_DONE) {
				if (hl_appl->addnodetimer) {
					g_source_remove(hl_appl->addnodetimer);
					hl_appl->addnodetimer = 0;
					printf("Rmove add/rm timeout timer\n");
				}
				hl_nw_add_node_promote(hl_appl, node_id);
			}
			break;

		case ZWNET_OP_RESET:
			printf("Reset status:%d\n", sts);
			if (sts == OP_DONE) {
				hl_appl->node_status = RESET_NW_STS_DONE;
			} else if (sts == OP_FAILED) {
				hl_appl->node_status = RESET_NW_STS_UNKNOWN;
			}
		default:
			printf("hl_nw_notify_cb op:%u, status:%u\n", (unsigned)op, (unsigned)sts);
	}
}


/**
  lib_init - Initialize library
  @param[in]	hl_appl		        The high-level api context
  @param[in]	host_port		    Host listening port
  @param[in]	zip_router_ip		Z/IP router IP address in numerical form
  @param[in]	use_ipv4		    Flag to indicate zip_router_ip is in IPv4 or IPv6 format. 1= IPv4; 0= IPv6
  @param[in]	dev_cfg_file_name	Device specific configuration database file name
  @param[in]	dtls_psk		    DTLS pre-shared key
  @param[in]	dtls_psk_len		DTLS pre-shared key length (in bytes)
  @param[in]	pref_dir		    Full path of directory for storing network/user preference files
  @return  0 on success, negative error number on failure
  */
int lib_init(hl_appl_ctx_t *hl_appl, uint16_t host_port, uint8_t *zip_router_ip, int use_ipv4,
		char *dev_cfg_file_name, uint8_t *dtls_psk, uint8_t dtls_psk_len, char *pref_dir)
{
	int                 result;
	zwnet_init_t        zw_init = {0};

	zw_init.user = hl_appl; //high-level application context
	zw_init.node = hl_nw_node_cb;
	zw_init.notify = hl_nw_notify_cb;
	zw_init.appl_tx = hl_nw_tx_cb;
	zw_init.pref_dir = pref_dir;
	zw_init.print_txt_fn = NULL;
	zw_init.net_info_dir = "/etc/config/zwave/";
	zw_init.host_port = host_port;
	zw_init.use_ipv4 = use_ipv4;
	memcpy(zw_init.zip_router, zip_router_ip, (use_ipv4)? IPV4_ADDR_LEN : IPV6_ADDR_LEN);
	zw_init.dev_cfg_file = dev_cfg_file_name;
	zw_init.dev_cfg_usr = NULL;
	zw_init.dtls_psk_len = dtls_psk_len;
	if (dtls_psk_len)
	{
		memcpy(zw_init.dtls_psk, dtls_psk, dtls_psk_len);
	}
	//Unhandled command handler
	zw_init.unhandled_cmd = NULL;

	//Init ZW network
	result = zwnet_init(&zw_init, &hl_appl->zwnet);

	if (result != 0)
	{
		printf("lib_init with error:%d\n", result);

		//Display device configuration file error
		if (zw_init.err_loc.dev_ent)
		{
			printf("Parsing device configuration file error loc:\n");
			printf("Device entry number:%u\n", zw_init.err_loc.dev_ent);
			if (zw_init.err_loc.ep_ent)
			{
				printf("Endpoint entry number:%u\n", zw_init.err_loc.ep_ent);
			}

			if (zw_init.err_loc.if_ent)
			{
				printf("Interface entry number:%u\n", zw_init.err_loc.if_ent);
			}
		}
		return result;
	}

	return 0;
}

/**
  hl_add_node_s2_cb - callback for add node with security 2 operation to report Device Specific Key (DSK)
  @param[in]	usr_param  user supplied parameter when calling zwnet_add
  @param[in]	cb_param   DSK related callback parameters
  */
static void hl_add_node_s2_cb(void *usr_param, sec2_add_cb_prm_t *cb_param)
{
	hl_appl_ctx_t *hl_appl = (hl_appl_ctx_t *)usr_param;
	int           res;

	if (cb_param->cb_type == S2_CB_TYPE_REQ_KEY)
	{
		uint8_t granted_key;
		uint8_t grant_csa;

		if (hl_appl->sec2_cb_enter & SEC2_ENTER_KEY_REQ)
		{   //Requested keys callback is allowed
			hl_appl->sec2_cb_enter &= ~SEC2_ENTER_KEY_REQ;
		}
		else
		{
			printf("\nNot allowed to processed Security 2 requested keys callback!\n");
			return;
		}

		printf("\nDevice requested keys bit-mask: %02Xh\n", cb_param->cb_prm.req_key.req_keys);

		printf("Key (bit-mask in hex) :\n");
		printf("                      Security 2 key 0 (01)\n");
		printf("                      Security 2 key 1 (02)\n");
		printf("                      Security 2 key 2 (04)\n");
		printf("                      Security 0       (80)\n");

		granted_key = prompt_hex(hl_appl, "Grant keys bit-mask (hex):");

		grant_csa = 0;
		if (cb_param->cb_prm.req_key.req_csa)
		{
			printf("Device requested for client-side authentication (CSA)\n");
			if (prompt_yes(hl_appl, "Grant CSA (y/n)?:"))
			{
				grant_csa = 1;
				printf("Please enter this 10-digit CSA Pin into the joining device:%s\n", cb_param->cb_prm.req_key.csa_pin);
			}
			//No DSK callback when in CSA mode
			hl_appl->sec2_cb_enter &= ~SEC2_ENTER_DSK;

		}

		res = zwnet_add_sec2_grant_key(hl_appl->zwnet, granted_key, grant_csa);

		if (res != 0)
		{
			printf("zwnet_add_sec2_grant_key with error: %d\n", res);
		}

		//Check whether if there is DSK callback pending
		if (!(hl_appl->sec2_cb_enter))
		{   //No callback pending
			hl_appl->sec2_cb_exit = 1;
		}
	}
	else
	{
		sec2_dsk_cb_prm_t   *dsk_prm;
		int                 accept;
		char                dsk_str[200];

		if (hl_appl->sec2_cb_enter & SEC2_ENTER_DSK)
		{   //DSK callback is allowed
			hl_appl->sec2_cb_enter &= ~SEC2_ENTER_DSK;
		}
		else
		{
			printf("\nNot allowed to processed Security 2 DSK callback!\n");
			return;
		}

		dsk_prm = &cb_param->cb_prm.dsk;

		if (dsk_prm->pin_required)
		{
			printf("\nReceived DSK: XXXXX%s\n", dsk_prm->dsk);
		}
		else
		{
			printf("\nReceived DSK: %s\n", dsk_prm->dsk);
		}

		accept = prompt_yes(hl_appl, "Do you accept this device to be added securely (y/n)?:");

		printf("You %s the device.\n", (accept)? "accepted" : "rejected");

		if (accept && dsk_prm->pin_required)
		{
			if (prompt_str(hl_appl, "Enter 5-digit PIN that matches the received DSK:", 200, dsk_str))
			{

#ifdef USE_SAFE_VERSION
				strcat_s(dsk_str, 200, dsk_prm->dsk);
#else
				strcat(dsk_str, dsk_prm->dsk);
#endif
			}
		}

		res = zwnet_add_sec2_accept(hl_appl->zwnet, accept, (dsk_prm->pin_required)? dsk_str : dsk_prm->dsk);

		if (res != 0)
		{
			printf("zwnet_add_sec2_accept with error: %d\n", res);
		}

		hl_appl->sec2_cb_exit = 1;
	}
}

static gboolean add_rm_node_abort_timeout_func(void *data)
{
	hl_appl_ctx_t *hl_appl = (hl_appl_ctx_t*)data;

	zwnet_abort(hl_appl->zwnet);
	hl_appl->addnodetimer = 0;
	hl_appl->node_status = RM_NODE_STS_UNKNOWN;
	printf("zwave node abort rm/add node\n");
	return FALSE;
}


/**
  hl_add_node - Add node
  @param[in]	hl_appl  Application context
  @return zero if successful; else negative error number
  */
static int hl_add_node(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	int     res;
	char    dsk_str[200];
	zwnetd_p netdesc;

	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jCmd= json_object_object_get(jDevopt, "cmd");
	int curops = 0;

	if (jCmd== NULL)  {
		printf("Json message need msg->value->(int) \n");
		return -1;
	}

	curops = json_object_get_int(jCmd);
	if ((curops == 0x01) && (hl_appl->node_status != ADD_NODE_STS_PROGRESS)) {
		printf("Add node called\n");
		netdesc = zwnet_get_desc(hl_appl->zwnet);

		if (netdesc->ctl_cap & ZWNET_CTLR_CAP_S2)
		{
			printf("Controller supports security 2.\n");
			hl_appl->sec2_add_node = 1;
		}
		else
		{
			hl_appl->sec2_add_node = 0;
		}

		if (hl_appl->sec2_add_node)
		{
			hl_appl->sec2_add_prm.dsk = NULL;
			hl_appl->sec2_add_prm.usr_param = hl_appl;
			hl_appl->sec2_add_prm.cb = hl_add_node_s2_cb;

		}

		res = zwnet_add(hl_appl->zwnet, 1, (hl_appl->sec2_add_node)? &hl_appl->sec2_add_prm : NULL, 0);

		if (res == 0)
		{
			if (hl_appl->sec2_add_node)
			{
				int wait_count;

				hl_appl->sec2_cb_enter = SEC2_ENTER_KEY_REQ;

				if (!hl_appl->sec2_add_prm.dsk)
				{   //No pre-entered DSK, requires DSK callback
					hl_appl->sec2_cb_enter |= SEC2_ENTER_DSK;
				}

				hl_appl->sec2_cb_exit = 0;

				printf("Waiting for Requested keys and/or DSK callback ...\n");
			}
		}

		hl_appl->node_status = ADD_NODE_STS_PROGRESS;
		hl_appl->addnodetimer = g_timeout_add(ADD_RM_DEVICE_TIMEOUT, add_rm_node_abort_timeout_func, (void*)hl_appl);
	} else if (curops == 2) {
		printf("stop Add node called\n");	
		zwnet_abort(hl_appl->zwnet);
		if (hl_appl->addnodetimer) {
			g_source_remove(hl_appl->addnodetimer);
			hl_appl->addnodetimer = 0;
		}
		hl_appl->node_status = RM_NODE_STS_DONE;
	}

	return res;
}

static void hl_rm_node(hl_appl_ctx_t *hl_appl, json_object *jObj) 
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jCmd = json_object_object_get(jDevopt, "cmd");
	int curops = 0;

	if (jCmd== NULL) {
		printf("Json message need msg->value->int \n");
		return -1;
	}
	curops = json_object_get_int(jCmd);
	if (curops == 1) {
		if (hl_appl->node_status != RM_NODE_STS_PROGRESS) {
			zwnet_add(hl_appl->zwnet, 0, NULL, 0);
			hl_appl->node_status = RM_NODE_STS_PROGRESS;
			hl_appl->addnodetimer = g_timeout_add(ADD_RM_DEVICE_TIMEOUT, add_rm_node_abort_timeout_func, (void*)hl_appl);
		}
	} else if (curops == 2) {
		printf("stop Rm node called\n");	
		zwnet_abort(hl_appl->zwnet);
		if (hl_appl->addnodetimer) {
			g_source_remove(hl_appl->addnodetimer);
			hl_appl->addnodetimer = 0;
		}
		hl_appl->node_status = RM_NODE_STS_DONE;
	}
}

static void send_switch_binary_set_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char value)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SWITCH_BINARY, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_switch_set(&intf, value);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_switch_binary_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SWITCH_BINARY, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_switch_get(&intf, ZWIF_GET_BMSK_CACHE);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_basic_set_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char value)
{
	zwifd_t intf;
	int result;

	result  = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_BASIC, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_basic_set(&intf, value);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_basic_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result  = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_BASIC, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_basic_get(&intf, ZWIF_GET_BMSK_CACHE);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_doorlock_set_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char value)
{
	zwifd_t intf;
	int result;

	result  = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_DOOR_LOCK, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_dlck_op_set(&intf, ZW_DOOR_UNSEC, NULL, NULL);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_level_set_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char value)
{
	zwifd_t intf;
	int result;

	result  = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SWITCH_MULTILEVEL, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_level_set(&intf, value, 255, NULL, NULL);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_level_stop_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SWITCH_MULTILEVEL, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_level_stop(&intf);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_level_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result  = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SWITCH_MULTILEVEL, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_level_get(&intf, ZWIF_GET_BMSK_CACHE);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_sensor_binary_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char value)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SENSOR_BINARY, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_bsensor_get(&intf, value, ZWIF_GET_BMSK_CACHE);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_battery_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_BATTERY, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_battery_get(&intf, ZWIF_GET_BMSK_CACHE);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_dlck_op_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_DOOR_LOCK, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_dlck_op_get(&intf, ZWIF_GET_BMSK_CACHE);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void send_sensor_level_get_by_nodeid_endpint(zwnet_p net, unsigned char nodeid, unsigned char endpoint, unsigned char attr)
{
	zwifd_t intf;
	int result;

	result = zwnet_get_if_by_id(net, nodeid, endpoint, COMMAND_CLASS_SENSOR_MULTILEVEL, &intf);
	if (result == 0) {
		printf("----------------------------------->Found nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
		zwif_sensor_get(&intf, attr, 0, ZWIF_GET_BMSK_CACHE);
	}
	else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", nodeid, endpoint);
	}
}
static void dump_dsk_func(void *usr_ctx, char *dsk)
{
	printf("-----------dump_dsk_func---------------------\n");
	printf("-----------dump_dsk_func---------------------\n");
	printf("-----------dump_dsk_func---------------------\n");
	printf("-----------dump_dsk_func---------------------\n");
}
static void hl_net_join_other_network(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	printf("-----------------join other network----------------");
	zwnet_initiate(hl_appl->zwnet, dump_dsk_func, (void*)hl_appl);
	return;
}
static void hl_net_reset(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	printf("-----------reset gateway-----\n");
	hl_appl->node_status = RESET_NW_STS_PROGRESS;
	zwnet_reset(hl_appl->zwnet);
}

static void hl_node_control(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jAddr = json_object_object_get(jDevopt, "addr");
	json_object *jCmd = json_object_object_get(jDevopt, "cmd");
	json_object *jValue = json_object_object_get(jDevopt, "value");

	if ((jAddr == NULL) || (jCmd == NULL) || (jValue == NULL)) {
		printf("Check hl_node_control:jAddr=%p, jCmd=%p, jValue=%p\n", jAddr, jCmd, jValue);
		return;
	}
	int addr = json_object_get_int(jAddr);
	int command = json_object_get_int(jCmd);
	int value = json_object_get_int(jValue);

	unsigned char zcmdc = (unsigned char)(command >> 8);
	unsigned char zcmd = (unsigned char)command;
	unsigned char znodeid = (unsigned char)(addr >> 8);
	unsigned char endpoint = (unsigned char)(addr);
	
	printf("zcmdc=%02x, zcmd=%02x, znodeid=%02x, endpoint=%02x\n", zcmdc, zcmd, znodeid, endpoint);
	switch(zcmdc) {
		case COMMAND_CLASS_BASIC: 
			send_basic_set_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, value); 
			break;

		case COMMAND_CLASS_SWITCH_BINARY:
			send_switch_binary_set_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, value);
			break;

		case COMMAND_CLASS_DOOR_LOCK:
			send_doorlock_set_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, value);
			break;

		case COMMAND_CLASS_SWITCH_MULTILEVEL:
			if (zcmd == SWITCH_MULTILEVEL_SET) {
				send_level_set_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, value);
			}
			else if (zcmd == SWITCH_MULTILEVEL_STOP_LEVEL_CHANGE) {
				send_level_stop_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		default:
			break;
	}
}

static void hl_node_state_get(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jAddr = json_object_object_get(jDevopt, "addr");
	json_object *jCmd = json_object_object_get(jDevopt, "cmd");
	json_object *jValue = json_object_object_get(jDevopt, "value");

	if ((jAddr == NULL) || (jCmd == NULL)) {
		printf("Check hl_node_control:jAddr=%p, jCmd=%p\n", jAddr, jCmd);
		return;
	}
	int addr = json_object_get_int(jAddr);
	int command = json_object_get_int(jCmd);

	unsigned char zcmdc = (unsigned char)(command >> 8);
	unsigned char zcmd = (unsigned char)command;
	unsigned char znodeid = (unsigned char)(addr >> 8);
	unsigned char endpoint = (unsigned char)(addr);

	printf("zcmdc=%02x, zcmd=%02x, znodeid=%02x, endpoint=%02x\n", zcmdc, zcmd, znodeid, endpoint);
	switch(zcmdc) {
		case COMMAND_CLASS_BASIC:
			if (zcmd == BASIC_GET) {
				send_basic_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		case COMMAND_CLASS_SWITCH_BINARY:
			if (zcmd == SWITCH_BINARY_GET) {
				send_switch_binary_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		case COMMAND_CLASS_SENSOR_BINARY:
			if ((zcmd == SENSOR_BINARY_GET) && (jValue != NULL)) {
				int value = json_object_get_int(jValue);
				unsigned char attr = (unsigned char)value;
				send_sensor_binary_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, attr);
			}
			break;

		case COMMAND_CLASS_SENSOR_ALARM:
			break;

		case COMMAND_CLASS_BATTERY:
			if (zcmd == BATTERY_GET) {
				send_battery_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		case COMMAND_CLASS_METER:
			break;

		case COMMAND_CLASS_DOOR_LOCK:
			if (zcmd == DOOR_LOCK_OPERATION_GET) {
				send_dlck_op_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		case COMMAND_CLASS_SENSOR_MULTILEVEL:
			if ((zcmd == SENSOR_MULTILEVEL_GET) && (jValue != NULL)) {
				int value = json_object_get_int(jValue);
				unsigned char attr = (unsigned char)value;
				send_sensor_level_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint, attr);
			}
			break;

		case COMMAND_CLASS_SWITCH_MULTILEVEL:
			if (zcmd == SWITCH_MULTILEVEL_GET) {
				send_level_get_by_nodeid_endpint(hl_appl->zwnet, znodeid, endpoint);
			}
			break;

		default:
			break;
	}
}

static void hl_node_dump(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jAddr = json_object_object_get(jDevopt, "addr");

	if ((jAddr == NULL)) {
		printf("Check hl_node_control:jAddr=%p\n", jAddr);
		return;
	}
	int addr = json_object_get_int(jAddr);

	unsigned char znodeid = (unsigned char)(addr >> 8);
	unsigned char endpoint = (unsigned char)(addr);
	
	hl_nw_new_node_parse_by_nodeid(hl_appl, znodeid);	
	return 0;
}

static void hl_node_list_get(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jCmd = json_object_object_get(jDevopt, "cmd");
	int curops = 0;

	if (jCmd== NULL) {
		printf("Json message need msg->value->int \n");
		return -1;
	}
	curops = json_object_get_int(jCmd);
	if (curops == 1) {
		hl_nw_alldevices_node_list(hl_appl);
	}
}

static void hl_net_test_func(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jDevopt = json_object_object_get(jObj, DEVICE_OPT);
	json_object *jAddr = json_object_object_get(jDevopt, "addr");

	if ((jAddr == NULL)) {
		printf("Check hl_node_control:jAddr=%p\n", jAddr);
		return;
	}
	int addr = json_object_get_int(jAddr);
	zwifd_t intf;

	unsigned char znodeid = (unsigned char)(addr >> 8);
	unsigned char endpoint = (unsigned char)(addr);
	
	int result;
	result =  zwnet_get_if_by_id(hl_appl->zwnet, znodeid, endpoint, COMMAND_CLASS_BASIC, &intf);
	if (result == 0) {
		printf("----------------------------------->Found znodeid[%d] endpoint[%d]\n", znodeid, endpoint);
	} else {
		printf("Unfound nodeid[%d] endpoint[%d]\n", znodeid, endpoint);
		return;
	}
	zwif_basic_get(&intf, ZWIF_GET_BMSK_CACHE);
}
static void process_one_zwave_json_command(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	printf("zwave json object process:\n");
	printf("%s\n", json_object_to_json_string(jObj));
	json_object *jtype = json_object_object_get(jObj, "type"); 
	if (jtype == NULL) return;	

	switch(json_object_get_int(jtype)) {
		case MQTT_ZWAVE_COMMAND_TYPE_EXCLUSION:
			hl_rm_node(hl_appl, jObj);	
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_INCLUSION:
			hl_add_node(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_CONTROL:
			hl_node_control(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_STATE_GET:
			hl_node_state_get(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_JOIN_OTHER_NETWORK:
			hl_net_join_other_network(hl_appl, jObj);
			break;
		case MQTT_ZWAVE_COMMAND_TYPE_DUMP_NODE:
			hl_node_dump(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_GET_DEVLIST:
			hl_node_list_get(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_RESET_NETWORK:
			hl_net_reset(hl_appl, jObj);
			break;

		case MQTT_ZWAVE_COMMAND_TYPE_TEST:
			hl_net_test_func(hl_appl, jObj);
			break;

		default:
			break;
	}
	return;
}
static void process_one_common_json_command(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	json_object *jtype = json_object_object_get(jObj, "type");  
	if (jtype == NULL) return;

	printf("jtype=%d\n", json_object_get_int(jtype));
	switch(json_object_get_int(jtype)) {
		case MQTT_JSON_PROTOCAL_ANY_TYPE_SCENE:
			process_one_scene_command(hl_appl->gClient, jObj);
			break;

		case MQTT_JSON_PROTOCAL_ANY_TYPE_LINKAGE:
			process_one_linkage_command(hl_appl->gClient, jObj);
			break;
		default:
			break;
	}
}
static void process_one_json_command(hl_appl_ctx_t *hl_appl, json_object *jObj)
{
	printf("Got one json command\n");
	printf("%s\n", json_object_to_json_string(jObj));
	json_object *jprotocal = json_object_object_get(jObj, "protocal");

	if (jprotocal == NULL) return;
	switch(json_object_get_int(jprotocal)) {
		case MQTT_JSON_PROTOCAL_ZWAVE_ID:
			printf("start to process zwave json command:--->\n");
			process_one_zwave_json_command(hl_appl, jObj);
			printf("<---:end json command\n");
			break;
		
		case MQTT_JSON_PROTOCAL_ANY:
			printf("Common protocal command\n");
			process_one_common_json_command(hl_appl, jObj);
			break;

		deafault:
			break;
	}
}

static void *zwave_mqtt_thread_func(void *data)
{
	hl_appl_ctx_t  *hl_appl = (hl_appl_ctx_t *)data;
	struct Global_Client *gClient = hl_appl->gClient;
	json_object *jObj = NULL;
	
	gClient->mqttCmdThreadRun = TRUE;
	while(!gClient->mqttCmdThreadExit) {
		g_mutex_lock(&gClient->MqttCmdMutex);
		while((g_slist_length(gClient->pMqttCmdList) == 0) && !gClient->mqttCmdThreadExit) 
			g_cond_wait(&gClient->MqttCmdCond, &gClient->MqttCmdMutex);
		jObj = g_slist_nth_data(gClient->pMqttCmdList, 0);
		if (jObj != NULL) {
			gClient->pMqttCmdList = g_slist_remove(gClient->pMqttCmdList, jObj);
		}
		g_mutex_unlock(&gClient->MqttCmdMutex);
		if (gClient->mqttCmdThreadExit) {
			break;
		}
		if (jObj == NULL) continue;

		//process one json object
		process_one_json_command(hl_appl, jObj);
		json_object_put(jObj);
	}
	gClient->mqttCmdThreadRun = FALSE;
	return NULL;
}
/**
  nw_init - initialization network
  @param[in] hl_appl   user application context
  @return  0 on success; otherwise negative number
  */
int nw_init(struct Global_Client *pClient)
{
	int             ret;
	uint8_t         zip_gw_ip[16];              ///< Z/IP gateway address in IPv4 or IPv6

	hl_appl_ctx_t *hl_appl = &g_appl_ctx;

	hl_appl->node_status = ADD_NODE_STS_DONE;	
	hl_appl->addnodetimer = 0;
	g_appl_ctx.gClient = pClient;   

	ret = zwnet_ip_aton("fd00:aaaa::3", zip_gw_ip, &hl_appl->use_ipv4);

	if (ret != 0)
	{
		return ZW_ERR_IP_ADDR;
	}

	ret = lib_init(hl_appl, 4123, zip_gw_ip, hl_appl->use_ipv4, "/etc/config/zwave/zwave_device_rec.txt",
			NULL, 0, "/etc/zwave/");

	if (ret < 0)
	{
		printf("lib_init with error: %d\n", ret);
	}

	//create one thread for execute mqtt command
	pClient->mqttCmdThreadExit = FALSE;
	pClient->mqttCmdThreadRun = FALSE;
	pClient->pMqttCmdThread = g_thread_new("mqttcmd", zwave_mqtt_thread_func, (void*)hl_appl); 
	while(!pClient->mqttCmdThreadRun) {
		g_usleep(1000);
	}
	return ret;
}

int nw_deinit(hl_appl_ctx_t *hl_appl) 
{
	struct Global_Client *pClient = hl_appl->gClient;

	pClient->mqttCmdThreadExit = TRUE;
	g_cond_signal(&pClient->MqttCmdCond);
	while(pClient->mqttCmdThreadRun) {
		g_usleep(1000);
	}
	zwnet_exit(hl_appl->zwnet);
	return 0;
}
